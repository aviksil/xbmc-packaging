From 25f4ad9f7182847fed7547a2fd38493bfa884a22 Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Thu, 1 Dec 2011 21:22:39 -0600
Subject: [PATCH 05/10] WIP: add eglImageExternal support for GStreamer
 decoder (v2)

GStreamer decoder sends eglImage's to renderer, and implement cropping in
display.

There is still some sort of race-condition and occasional crash at end
of playback to debug.
---
 .../shaders/yuv2rgb_egl_image_external_gles.glsl   |   46 +++
 .../yuv2rgb_vertex_egl_image_external_gles.glsl    |   33 ++
 xbmc/cores/VideoRenderers/BaseRenderer.h           |    5 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |  308 +++++++++++++++++---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |   22 ++-
 xbmc/cores/VideoRenderers/RenderFlags.h            |    1 +
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    4 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |   56 ++++
 .../VideoRenderers/VideoShaders/YUV2RGBShader.h    |   30 ++
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |    2 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |   37 +++
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.cpp     |  153 +++++++++--
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.h       |   18 ++
 .../cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp |   10 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h  |    2 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |    4 +
 xbmc/system.h                                      |    2 +
 17 files changed, 664 insertions(+), 69 deletions(-)
 create mode 100644 system/shaders/yuv2rgb_egl_image_external_gles.glsl
 create mode 100644 system/shaders/yuv2rgb_vertex_egl_image_external_gles.glsl

diff --git a/system/shaders/yuv2rgb_egl_image_external_gles.glsl b/system/shaders/yuv2rgb_egl_image_external_gles.glsl
new file mode 100644
index 0000000..6914f88
--- /dev/null
+++ b/system/shaders/yuv2rgb_egl_image_external_gles.glsl
@@ -0,0 +1,46 @@
+/*
+ *      Copyright (C) 2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * The texture object uses the GL_TEXTURE_EXTERNAL_OES texture target, which
+ * is defined by the GL_OES_EGL_image_external OpenGL ES extension. This
+ * limits how the texture may be used. Each time the texture is bound it
+ * must be bound to the GL_TEXTURE_EXTERNAL_OES target rather than the
+ * GL_TEXTURE_2D target. Additionally, any OpenGL ES 2.0 shader that samples
+ * from the texture must declare its use of this extension using, for example,
+ * an "#extension GL_OES_EGL_image_external : require" directive. Such shaders
+ * must also access the texture using the samplerExternalOES GLSL sampler type.
+ */
+
+#extension GL_OES_EGL_image_external : require
+
+precision mediump float;
+
+uniform samplerExternalOES m_samp;
+varying vec2   m_cord;
+uniform float  m_alpha;
+
+void main()
+{
+  vec4 rgb = texture2D(m_samp, m_cord);
+  rgb.a = m_alpha;
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/yuv2rgb_vertex_egl_image_external_gles.glsl b/system/shaders/yuv2rgb_vertex_egl_image_external_gles.glsl
new file mode 100644
index 0000000..c3f1f14
--- /dev/null
+++ b/system/shaders/yuv2rgb_vertex_egl_image_external_gles.glsl
@@ -0,0 +1,33 @@
+/*
+ *      Copyright (C) 2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+attribute vec4 m_attrpos;
+attribute vec2 m_attrcord;
+varying vec2 m_cord;
+uniform mat4 m_proj;
+uniform mat4 m_model;
+
+void main ()
+{
+  mat4 mvp    = m_proj * m_model;
+  gl_Position = mvp * m_attrpos;
+  m_cord      = m_attrcord;
+}
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index af51852..7373a69 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -32,8 +32,9 @@ typedef struct YV12Image
   BYTE *   plane[MAX_PLANES];
   int      planesize[MAX_PLANES];
   unsigned stride[MAX_PLANES];
-  unsigned width;
-  unsigned height;
+  unsigned cropX, cropY;          /* crop position */
+  unsigned cropWidth, cropHeight; /* crop dimensions */
+  unsigned width, height;         /* original dimensions */
   unsigned flags;
 
   unsigned cshift_x; /* this is the chroma shift used */
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 6af7ebf..43bf3f0 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -54,6 +54,19 @@
 #ifdef TARGET_DARWIN_IOS
 #include "osx/DarwinUtils.h"
 #endif
+#include <EGL/eglext.h>
+
+#ifdef HAVE_LIBGSTREAMER
+#include <gst/gst.h>
+#endif
+
+/* for debug */
+#undef VerifyGLState
+#define VerifyGLState()  do { \
+    GLenum err = glGetError(); \
+    if (err!=GL_NO_ERROR) \
+    printf("%s:%d: fail: GL ERROR: %d\n", __FILE__, __LINE__, err); \
+} while (0)
 
 using namespace Shaders;
 
@@ -70,7 +83,7 @@ CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
 
 CLinuxRendererGLES::CLinuxRendererGLES()
 {
-  m_textureTarget = GL_TEXTURE_2D;
+  memset(m_buffers, 0, sizeof(m_buffers));
   for (int i = 0; i < NUM_BUFFERS; i++)
   {
     m_eventTexturesDone[i] = new CEvent(false,true);
@@ -105,13 +118,40 @@ CLinuxRendererGLES::CLinuxRendererGLES()
 
   m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
+
+  glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)
+      eglGetProcAddress("glEGLImageTargetTexture2DOES");
+
+#if 0
+  if (m_hasEglImage)
+  {
+    const char *exts = (const char *)glGetString(GL_EXTENSIONS);
+    if (!(strstr(exts, "GL_OES_EGL_image_external") &&
+        strstr(exts, "GL_TI_image_external_raw_videoPre")))  // note: using pre-finalized API..
+      m_hasEglImage = false;
+  }
+#endif
+
+  m_textureTarget = GL_TEXTURE_2D;
+}
+
+void CLinuxRendererGLES::UnRefBuf(int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.eglImage)
+    buf.decoder->ReleaseEGLImage(buf.eglImage, buf.origBuf);
+  buf.eglImage = NULL;
+  buf.origBuf = NULL;
+  buf.decoder = NULL;
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
 {
   UnInit();
-  for (int i = 0; i < NUM_BUFFERS; i++)
+  for (int i = 0; i < NUM_BUFFERS; i++) {
+    UnRefBuf(i);
     delete m_eventTexturesDone[i];
+  }
 
   if (m_rgbBuffer != NULL) {
     delete [] m_rgbBuffer;
@@ -130,7 +170,7 @@ CLinuxRendererGLES::~CLinuxRendererGLES()
 
 void CLinuxRendererGLES::ManageTextures()
 {
-  m_NumYV12Buffers = 2;
+  m_NumYV12Buffers = NUM_BUFFERS;
   //m_iYV12RenderBuffer = 0;
   return;
 }
@@ -266,15 +306,18 @@ void CLinuxRendererGLES::CalculateTextureSourceRects(int source, int num_planes)
   YUVFIELDS& fields =  buf.fields;
 
   // calculate the source rectangle
-  for(int field = 0; field < 3; field++)
+  for(int field = 0; field < (buf.eglImage ? 1 : 3); field++)
   {
     for(int plane = 0; plane < num_planes; plane++)
     {
       YUVPLANE& p = fields[field][plane];
 
-      p.rect = m_sourceRect;
-      p.width  = im->width;
-      p.height = im->height;
+      p.rect.x1 = im->cropX;
+      p.rect.y1 = im->cropY;
+      p.rect.x2 = im->cropX + im->cropWidth;
+      p.rect.y2 = im->cropY + im->cropHeight;
+      p.width   = im->cropWidth;
+      p.height  = im->cropHeight;
 
       if(field != FIELD_FULL)
       {
@@ -305,7 +348,8 @@ void CLinuxRendererGLES::CalculateTextureSourceRects(int source, int num_planes)
         p.rect.y2 /= 1 << im->cshift_y;
       }
 
-      if (m_textureTarget == GL_TEXTURE_2D)
+      if ((m_textureTarget == GL_TEXTURE_2D) ||
+          (m_textureTarget == GL_TEXTURE_EXTERNAL_OES))
       {
         p.height  /= p.texheight;
         p.rect.y1 /= p.texheight;
@@ -331,7 +375,7 @@ void CLinuxRendererGLES::LoadPlane( YUVPLANE& plane, int type, unsigned flipinde
   // OpenGL ES does not support strided texture input. Make a copy without stride
   if(stride != width)
   {
-    pixelVector = (char *)malloc(width * height * width);
+    pixelVector = (char *)malloc(width * height);
     
     const char *src = (const char *)data;
     char *dst = pixelVector;
@@ -426,10 +470,15 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   if (CONF_FLAGS_FORMAT_MASK(m_iFlags) != CONF_FLAGS_FORMAT_OMXEGL)
   {
-    if (!buf.fields[FIELD_FULL][0].id) return;
+    if (!buf.fields[FIELD_FULL][0].id)
+{printf("fail 1\n");
+      return;
+}
   }
   if (buf.image.flags==0)
+{printf("fail 2\n");
     return;
+}
 
   ManageDisplay();
   ManageTextures();
@@ -508,7 +557,7 @@ unsigned int CLinuxRendererGLES::PreInit()
     m_resolution = RES_DESKTOP;
 
   m_iYV12RenderBuffer = 0;
-  m_NumYV12Buffers = 2;
+  m_NumYV12Buffers = NUM_BUFFERS;
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
@@ -631,9 +680,17 @@ void CLinuxRendererGLES::LoadShaders(int field)
       // Try GLSL shaders if supported and user requested auto or GLSL.
       if (glCreateProgram)
       {
-        // create regular progressive scan shader
-        m_pYUVShader = new YUV2RGBProgressiveShader(false, m_iFlags);
-        CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
+        if (CONF_FLAGS_FORMAT_MASK(m_iFlags) == CONF_FLAGS_FORMAT_EGLIMG)
+        {
+          m_pYUVShader = new EGLImageExternalShader();
+          CLog::Log(LOGNOTICE, "GL: Selecting eglImage shader");
+        }
+        else
+        {
+          // create regular progressive scan shader
+          m_pYUVShader = new YUV2RGBProgressiveShader(false, m_iFlags);
+          CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
+        }
 
         if (m_pYUVShader && m_pYUVShader->CompileAndLink())
         {
@@ -653,6 +710,7 @@ void CLinuxRendererGLES::LoadShaders(int field)
     case RENDER_METHOD_SOFTWARE:
     default:
       {
+printf("fail SW!!\n");
         // Use software YUV 2 RGB conversion if user requested it or GLSL failed
         m_renderMethod = RENDER_SW ;
         CLog::Log(LOGNOTICE, "GL: Using software color conversion/RGBA rendering");
@@ -682,6 +740,12 @@ void CLinuxRendererGLES::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGLES::CreateBYPASSTexture;
     m_textureDelete = &CLinuxRendererGLES::DeleteBYPASSTexture;
   }
+  else if (CONF_FLAGS_FORMAT_MASK(m_iFlags) == CONF_FLAGS_FORMAT_EGLIMG)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadEGLIMAGETexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateEGLIMAGETexture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteEGLIMAGETexture;
+  }
   else
   {
     // default to YV12 texture handlers
@@ -726,7 +790,7 @@ void CLinuxRendererGLES::Render(DWORD flags, int index)
     return;
 
   // obtain current field, if interlaced
-  if( flags & RENDER_FLAG_TOP)
+  if (flags & RENDER_FLAG_TOP)
     m_currentField = FIELD_TOP;
 
   else if (flags & RENDER_FLAG_BOT)
@@ -778,8 +842,9 @@ void CLinuxRendererGLES::Render(DWORD flags, int index)
 
 void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 {
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVBUFFER &buf    = m_buffers[index];
+  YV12Image &im     = buf.image;
+  YUVFIELDS &fields = buf.fields;
   YUVPLANES &planes = fields[field];
 
   if (m_reloadShaders)
@@ -790,20 +855,29 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 
   glDisable(GL_DEPTH_TEST);
 
+  /* note: with eglimageexternal, we have just a single YUV texture,
+   * rather than one texture per plane.  So what is referred below
+   * as the 'Y' texture is actually the 'YUV' texture, and 'U' & 'V'
+   * textures are unused.
+   */
+
   // Y
   glActiveTexture(GL_TEXTURE0);
   glEnable(m_textureTarget);
   glBindTexture(m_textureTarget, planes[0].id);
 
-  // U
-  glActiveTexture(GL_TEXTURE1);
-  glEnable(m_textureTarget);
-  glBindTexture(m_textureTarget, planes[1].id);
+  if (!buf.eglImage)
+  {
+    // U
+    glActiveTexture(GL_TEXTURE1);
+    glEnable(m_textureTarget);
+    glBindTexture(m_textureTarget, planes[1].id);
 
-  // V
-  glActiveTexture(GL_TEXTURE2);
-  glEnable(m_textureTarget);
-  glBindTexture(m_textureTarget, planes[2].id);
+    // V
+    glActiveTexture(GL_TEXTURE2);
+    glEnable(m_textureTarget);
+    glBindTexture(m_textureTarget, planes[2].id);
+  }
 
   glActiveTexture(GL_TEXTURE0);
   VerifyGLState();
@@ -818,9 +892,10 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
     m_pYUVShader->SetField(0);
 
   m_pYUVShader->SetMatrices(g_matrices.GetMatrix(MM_PROJECTION), g_matrices.GetMatrix(MM_MODELVIEW));
-  m_pYUVShader->Enable();
+  if (!m_pYUVShader->Enable())
+    printf("FAAAAAIIIILLLL!!\n");
 
-  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
+  const GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
   GLfloat m_vert[4][3];
   GLfloat m_tex[3][4][2];
 
@@ -831,13 +906,19 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 
   glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, 0, m_vert);
   glVertexAttribPointer(Yloc, 2, GL_FLOAT, 0, 0, m_tex[0]);
-  glVertexAttribPointer(Uloc, 2, GL_FLOAT, 0, 0, m_tex[1]);
-  glVertexAttribPointer(Vloc, 2, GL_FLOAT, 0, 0, m_tex[2]);
+  if (!buf.eglImage)
+  {
+    glVertexAttribPointer(Uloc, 2, GL_FLOAT, 0, 0, m_tex[1]);
+    glVertexAttribPointer(Vloc, 2, GL_FLOAT, 0, 0, m_tex[2]);
+  }
 
   glEnableVertexAttribArray(vertLoc);
   glEnableVertexAttribArray(Yloc);
-  glEnableVertexAttribArray(Uloc);
-  glEnableVertexAttribArray(Vloc);
+  if (!buf.eglImage)
+  {
+    glEnableVertexAttribArray(Uloc);
+    glEnableVertexAttribArray(Vloc);
+  }
 
   // Setup vertex position values
   m_vert[0][0] = m_vert[3][0] = m_destRect.x1;
@@ -847,7 +928,7 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
   m_vert[0][2] = m_vert[1][2] = m_vert[2][2] = m_vert[3][2] = 0.0f;
 
   // Setup texture coordinates
-  for (int i=0; i<3; i++)
+  for (int i = 0; i < (buf.eglImage ? 1 : 3); i++)
   {
     m_tex[i][0][0] = m_tex[i][3][0] = planes[i].rect.x1;
     m_tex[i][0][1] = m_tex[i][1][1] = planes[i].rect.y1;
@@ -864,14 +945,17 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 
   glDisableVertexAttribArray(vertLoc);
   glDisableVertexAttribArray(Yloc);
-  glDisableVertexAttribArray(Uloc);
-  glDisableVertexAttribArray(Vloc);
+  if (!buf.eglImage)
+  {
+    glDisableVertexAttribArray(Uloc);
+    glDisableVertexAttribArray(Vloc);
 
-  glActiveTexture(GL_TEXTURE1);
-  glDisable(m_textureTarget);
+    glActiveTexture(GL_TEXTURE1);
+    glDisable(m_textureTarget);
 
-  glActiveTexture(GL_TEXTURE2);
-  glDisable(m_textureTarget);
+    glActiveTexture(GL_TEXTURE2);
+    glDisable(m_textureTarget);
+  }
 
   glActiveTexture(GL_TEXTURE0);
   glDisable(m_textureTarget);
@@ -883,6 +967,9 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 
 void CLinuxRendererGLES::RenderMultiPass(int index, int field)
 {
+// XXX for debugging
+abort();
+
   // TODO: Multipass rendering does not currently work! FIX!
   CLog::Log(LOGERROR, "GLES: MULTIPASS rendering was called! But it doesnt work!!!");
   return;
@@ -1075,6 +1162,9 @@ void CLinuxRendererGLES::RenderSoftware(int index, int field)
 {
   YUVPLANES &planes = m_buffers[index].fields[field];
 
+// XXX for debugging
+abort();
+
   glDisable(GL_DEPTH_TEST);
 
   // Y
@@ -1307,6 +1397,102 @@ bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 }
 
 //********************************************************************************************************
+// eglImage Texture creation, deletion, copying + clearing
+//********************************************************************************************************
+
+void CLinuxRendererGLES::UploadEGLIMAGETexture(int index)
+{
+  YUVBUFFER &buf    = m_buffers[index];
+  YV12Image &im     = buf.image;
+  YUVFIELDS &fields = buf.fields;
+  YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
+
+#if defined(HAVE_LIBOPENMAX)
+  if (!(im.flags&IMAGE_FLAG_READY) || buf.openMaxBuffer)
+#else
+  if (!(im.flags&IMAGE_FLAG_READY))
+#endif
+  {
+printf("fail READY!\n");
+    m_eventTexturesDone[index]->Set();
+    return;
+  }
+
+  glEnable(m_textureTarget);
+  glBindTexture(m_textureTarget, plane.id);
+  glEGLImageTargetTexture2DOES(m_textureTarget, buf.eglImage);
+
+  // XXX deal with cropping!!
+
+  VerifyGLState();
+
+  m_eventTexturesDone[index]->Set();
+
+  CalculateTextureSourceRects(index, 1);
+
+  glDisable(m_textureTarget);
+}
+
+void CLinuxRendererGLES::DeleteEGLIMAGETexture(int index)
+{
+  YUVBUFFER &buf    = m_buffers[index];
+  YV12Image &im     = buf.image;
+  YUVFIELDS &fields = buf.fields;
+  YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
+
+  if (plane.id == 0)
+    return;
+
+  /* finish up all textures, and delete them */
+  g_graphicsContext.BeginPaint();  //FIXME
+
+  if (glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id);
+
+  plane.id = 0;
+
+  UnRefBuf(index);
+
+  g_graphicsContext.EndPaint();
+}
+
+bool CLinuxRendererGLES::CreateEGLIMAGETexture(int index)
+{
+  YUVBUFFER &buf    = m_buffers[index];
+  YV12Image &im     = buf.image;
+  YUVFIELDS &fields = buf.fields;
+  YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
+
+  /* only use single-pass for egl-image-external */
+  m_renderQuality = RQ_SINGLEPASS;
+  m_textureTarget = GL_TEXTURE_EXTERNAL_OES;
+
+  DeleteEGLIMAGETexture(index);
+
+  glEnable(m_textureTarget);
+
+  if (!glIsTexture(plane.id))
+  {
+    glGenTextures(1, &plane.id);
+    VerifyGLState();
+  }
+
+  glBindTexture(m_textureTarget, plane.id);
+
+  // glTexImage2D(m_textureTarget, 0, GL_RGBA, plane.texwidth, plane.texheight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  VerifyGLState();
+
+  m_eventTexturesDone[index]->Set();
+
+  return true;
+}
+
+//********************************************************************************************************
 // YV12 Texture creation, deletion, copying + clearing
 //********************************************************************************************************
 void CLinuxRendererGLES::UploadYV12Texture(int source)
@@ -1554,7 +1740,7 @@ bool CLinuxRendererGLES::CreateYV12Texture(int index)
       }
     }
 
-    for(int p = 0; p < 3; p++)
+    for(int p = 0; p < MAX_PLANES; p++)
     {
       YUVPLANE &plane = planes[p];
       if (plane.texwidth * plane.texheight == 0)
@@ -1747,7 +1933,8 @@ void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 {
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
   {
-    YUVFIELDS &fields = m_buffers[i].fields;
+    YUVBUFFER &buf = m_buffers[i];
+    YUVFIELDS &fields = buf.fields;
 
     for (int f = FIELD_FULL; f<=FIELD_BOT ; f++)
     {
@@ -1756,7 +1943,7 @@ void CLinuxRendererGLES::SetTextureFilter(GLenum method)
       glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, method);
       VerifyGLState();
 
-      if (!(m_renderMethod & RENDER_SW))
+      if (!((m_renderMethod & RENDER_SW) || buf.eglImage))
       {
         glBindTexture(m_textureTarget, fields[f][1].id);
         glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, method);
@@ -1884,5 +2071,44 @@ void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecVideoToolBox* vtb, DVDVideoP
 }
 #endif
 
+/* for decoders using eglImage:
+ */
+void CLinuxRendererGLES::AddProcessor(DVDVideoPicture *picture)
+{
+  int index = NextYV12Texture();
+  YUVBUFFER &buf = m_buffers[index];
+  YV12Image &im  = buf.image;
+  YUVFIELDS &fields = buf.fields;
+  YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
+
+  UnRefBuf(index);
+
+  im.cropX      = picture->iDisplayX;
+  im.cropY      = picture->iDisplayY;
+  im.cropHeight = picture->iDisplayHeight;
+  im.cropWidth  = picture->iDisplayWidth;
+  im.width      = m_sourceWidth;
+  im.height     = m_sourceHeight;
+  im.cshift_x   = 1;
+  im.cshift_y   = 1;
+  buf.origBuf   = picture->origBuf;
+  buf.decoder   = picture->decoder;
+  buf.eglImage  = buf.decoder->GetEGLImage(buf.origBuf);
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+
+  if(m_renderMethod & RENDER_POT)
+  {
+    plane.texwidth  = NP2(plane.texwidth);
+    plane.texheight = NP2(plane.texheight);
+  }
+
+  // some sanity checking for now.. I plan to move the eglImage related
+  // stuff into the union, but need to be sure that no one is still using
+  // the data/iLineSize fields..
+  if (picture->data[0] || picture->iLineSize[0])
+    printf("warning: data/iLineSize is not zero!\n");
+}
 
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 3c7852a..69722ec 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -24,6 +24,11 @@
 
 #if HAS_GLES == 2
 
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
 #include "xbmc/guilib/FrameBufferObject.h"
 #include "xbmc/guilib/Shader.h"
 #include "settings/VideoSettings.h"
@@ -39,7 +44,7 @@ namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
 class COpenMaxVideo;
 
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 
 #undef ALIGN
@@ -160,6 +165,9 @@ public:
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   virtual void         AddProcessor(CDVDVideoCodecVideoToolBox* vtb, DVDVideoPicture *picture);
 #endif
+  /* for eglImage case: */
+  void AddProcessor(DVDVideoPicture *picture);
+
 protected:
   virtual void Render(DWORD flags, int index);
 
@@ -169,6 +177,7 @@ protected:
   virtual void LoadShaders(int field=FIELD_FULL);
   void SetTextureFilter(GLenum method);
   void UpdateVideoFilter();
+  void UnRefBuf(int index);
 
   // textures
   void (CLinuxRendererGLES::*m_textureUpload)(int index);
@@ -179,6 +188,10 @@ protected:
   void DeleteYV12Texture(int index);
   bool CreateYV12Texture(int index);
 
+  void UploadEGLIMAGETexture(int index);
+  void DeleteEGLIMAGETexture(int index);
+  bool CreateEGLIMAGETexture(int index);
+
   void UploadCVRefTexture(int index);
   void DeleteCVRefTexture(int index);
   bool CreateCVRefTexture(int index);
@@ -242,13 +255,16 @@ protected:
     YV12Image image;
     unsigned  flipindex; /* used to decide if this has been uploaded */
 
+    EGLImageKHR eglImage;
+    void *origBuf;
+    CDVDVideoCodec *decoder;
+
 #ifdef HAVE_LIBOPENMAX
     OpenMaxVideoBuffer *openMaxBuffer;
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   struct __CVBuffer *cvBufferRef;
 #endif
-
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
@@ -261,6 +277,8 @@ protected:
                 , unsigned width,  unsigned height
                 , int stride, void* data );
 
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
+
   Shaders::BaseYUV2RGBShader     *m_pYUVShader;
   Shaders::BaseVideoFilterShader *m_pVideoFilterShader;
   ESCALINGMETHOD m_scalingMethod;
diff --git a/xbmc/cores/VideoRenderers/RenderFlags.h b/xbmc/cores/VideoRenderers/RenderFlags.h
index f663380..1ab788c 100644
--- a/xbmc/cores/VideoRenderers/RenderFlags.h
+++ b/xbmc/cores/VideoRenderers/RenderFlags.h
@@ -80,4 +80,5 @@
 #define CONF_FLAGS_FORMAT_OMXEGL 0x040000
 #define CONF_FLAGS_FORMAT_CVBREF 0x080000
 #define CONF_FLAGS_FORMAT_BYPASS 0x100000
+#define CONF_FLAGS_FORMAT_EGLIMG 0x200000
 #endif
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 7da5eab..705ed18 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -619,7 +619,7 @@ void CXBMCRenderManager::Render(bool clear, DWORD flags, DWORD alpha)
   else
     PresentSingle(clear, flags, alpha);
 
-  m_overlays.Render();
+//XXX  m_overlays.Render();
 }
 
 void CXBMCRenderManager::Present()
@@ -773,6 +773,8 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
   else if(pic.format == DVDVideoPicture::FMT_CVBREF)
     m_pRenderer->AddProcessor(pic.vtb, &pic);
 #endif
+  else if(pic.format == DVDVideoPicture::FMT_EGLIMG)
+    m_pRenderer->AddProcessor(&pic);
 #ifdef HAVE_LIBVA
   else if(pic.format == DVDVideoPicture::FMT_VAAPI)
     m_pRenderer->AddProcessor(*pic.vaapi);
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index fa9f68a..f46d3c4 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -263,6 +263,62 @@ BaseYUV2RGBARBShader::BaseYUV2RGBARBShader(unsigned flags)
 }
 #endif
 
+
+//////////////////////////////////////////////////////////////////////
+// EGLImageExternalShader - YUV2RGB GL_OES_EGL_image_external extension
+// NOTE: this is a bit ugly, because don't have separate Y/U/V textures
+// (we just hijack the Y texture for now), and don't really have all
+// these other parameters (CSC matrix, etc..)
+//////////////////////////////////////////////////////////////////////
+
+EGLImageExternalShader::EGLImageExternalShader()
+{
+#ifdef HAS_GL
+#  error "Is this supported in GL??"
+#elif HAS_GLES == 2
+
+  m_width   = 1;
+  m_height  = 1;
+  m_hYTex   = -1;
+  m_hVertex = -1;
+  m_hYcoord = -1;
+  m_hProj   = -1;
+  m_hModel  = -1;
+  m_hAlpha  = -1;
+
+  VertexShader()->LoadSource("yuv2rgb_vertex_egl_image_external_gles.glsl", m_defines);
+  PixelShader()->LoadSource("yuv2rgb_egl_image_external_gles.glsl", m_defines);
+#endif
+}
+
+void EGLImageExternalShader::OnCompiledAndLinked()
+{
+  m_hAlpha  = glGetUniformLocation(ProgramHandle(), "m_alpha");
+  m_hProj   = glGetUniformLocation(ProgramHandle(), "m_proj");
+  m_hModel  = glGetUniformLocation(ProgramHandle(), "m_model");
+  m_hVertex = glGetAttribLocation(ProgramHandle(),  "m_attrpos");
+  m_hYcoord = glGetAttribLocation(ProgramHandle(),  "m_attrcord");
+  m_hYTex   = glGetUniformLocation(ProgramHandle(), "m_samp");
+
+printf("m_hVertex=%d, m_hYcoord=%d, m_hYTex=%d\n", m_hVertex, m_hYcoord, m_hYTex);
+printf("m_hAlpha=%d, m_hProj=%d, m_hModel=%d", m_hAlpha, m_hProj, m_hModel);
+
+  VerifyGLState();
+}
+
+bool EGLImageExternalShader::OnEnabled()
+{
+  // set shader attributes once enabled
+  glUniform1i(m_hYTex, 0);
+  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, m_proj);
+  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, m_model);
+  glUniform1f(m_hAlpha, m_alpha);
+
+  VerifyGLState();
+  return true;
+}
+
+
 //////////////////////////////////////////////////////////////////////
 // YUV2RGBProgressiveShader - YUV2RGB with no deinterlacing
 // Use for weave deinterlacing / progressive
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index bcc3a17..b6e2d49 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -164,6 +164,36 @@ namespace Shaders {
   };
 #endif
 
+  class EGLImageExternalShader : public BaseYUV2RGBShader, public CGLSLShaderProgram
+  {
+  public:
+    EGLImageExternalShader();
+    virtual void SetWidth(int w)     { m_width  = w; }
+    virtual void SetHeight(int h)    { m_height = h; }
+    virtual GLint GetVertexLoc() { return m_hVertex; }
+    virtual GLint GetYcoordLoc() { return m_hYcoord; }
+
+    virtual void SetMatrices(GLfloat *p, GLfloat *m) { m_proj = p; m_model = m; }
+    virtual void SetAlpha(GLfloat alpha) { m_alpha = alpha; }
+
+  protected:
+    void OnCompiledAndLinked();
+    bool OnEnabled();
+
+    string m_defines;
+    int   m_width;
+    int   m_height;
+    GLint m_hYTex;
+    GLint m_hVertex;
+    GLint m_hYcoord;
+    GLint m_hProj;
+    GLint m_hModel;
+    GLint m_hAlpha;
+    GLfloat *m_proj;
+    GLfloat *m_model;
+    GLfloat  m_alpha;
+  };
+
   class YUV2RGBProgressiveShader : public BaseYUV2RGBGLSLShader
   {
   public:
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 7deaee9..7f35df5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -172,7 +172,7 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
 #if defined(HAVE_LIBGSTREAMER)
-  if (/*hint.codec == CODEC_ID_H264*/true)
+  if (!hint.software)
   {
       CLog::Log(LOGINFO, "Trying GStreamer Video Decoder...");
       if ( (pCodec = OpenCodec(new CDVDVideoCodecGStreamer(), hint, options)) ) return pCodec;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index e4bd9c9..c1bd1b2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -34,6 +34,7 @@
 
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { struct CHolder; }
+class CDVDVideoCodec;
 class CVDPAU;
 class COpenMax;
 class COpenMaxVideo;
@@ -77,6 +78,17 @@ struct DVDVideoPicture
 #endif
   };
 
+  // XXX move this into union, and use instead of data/iLineSize!!
+    struct {
+      /* to allow the decoder to hold a reference to the original
+       * buffer that the eglImage was created from:
+       */
+      void *origBuf;
+      /* to implement unref of buffer:
+       */
+      CDVDVideoCodec *decoder;
+    };
+
   unsigned int iFlags;
 
   double       iRepeatPicture;
@@ -96,6 +108,7 @@ struct DVDVideoPicture
 
   unsigned int iWidth;
   unsigned int iHeight;
+  unsigned int iDisplayX, iDisplayY;
   unsigned int iDisplayWidth;  // width of the picture without black bars
   unsigned int iDisplayHeight; // height of the picture without black bars
 
@@ -109,6 +122,7 @@ struct DVDVideoPicture
     FMT_VAAPI,
     FMT_OMXEGL,
     FMT_CVBREF,
+    FMT_EGLIMG,
   } format;
 };
 
@@ -202,6 +216,29 @@ public:
   }
 
   /*
+   * Allow the decoder that supports eglImage to return an eglImage.  The
+   * decoder should put some sort of handle (or whatever it prefers) in to
+   * pDvdVideoPicture->origBuf.  This gets converted to an EGLImage by this
+   * method for buffers that the renderer will actually display (ie. not
+   * dropped).  And released by ::ReleaseEGLImage after they are rendered.
+   * This allows the decoder maximum flexibility, ie. up front creation of
+   * all the eglBuffers, or wrapping codec buffers after decode.
+   */
+  virtual EGLImageKHR GetEGLImage(void *origBuf)
+  {
+    return NULL; /* default not supported */
+  }
+
+  /*
+   * allow the decoder that supports eglImage to release the eglImage
+   * (if needed)
+   */
+  virtual void ReleaseEGLImage(EGLImageKHR eglImage, void *origBuf)
+  {
+    /* default no-op */
+  }
+
+  /*
    * will be called by video player indicating if a frame will eventually be dropped
    * codec can then skip actually decoding the data, just consume the data set picture headers
    */
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
index 8eb09cd..48d66e0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
@@ -26,11 +26,33 @@
 #include "DVDVideoCodecGStreamer.h"
 #include "DVDStreamInfo.h"
 #include "DVDClock.h"
+#include "windowing/WindowingFactory.h"
 #include <gst/app/gstappsrc.h>
 #include <gst/app/gstappsink.h>
+#include <EGL/egl.h>
 
 bool CDVDVideoCodecGStreamer::gstinitialized = false;
 
+
+#ifndef EGLIMAGE_FLAGS_YUV_CONFORMANT_RANGE
+// XXX these should come from some egl header??
+#define EGLIMAGE_FLAGS_YUV_CONFORMANT_RANGE (0 << 0)
+#define EGLIMAGE_FLAGS_YUV_FULL_RANGE       (1 << 0)
+#define EGLIMAGE_FLAGS_YUV_BT601            (0 << 1)
+#define EGLIMAGE_FLAGS_YUV_BT709            (1 << 1)
+#endif
+#ifndef EGL_TI_raw_video
+#  define EGL_TI_raw_video 1
+#  define EGL_RAW_VIDEO_TI            0x333A  /* eglCreateImageKHR target */
+#  define EGL_GL_VIDEO_FOURCC_TI        0x3331  /* eglCreateImageKHR attribute */
+#  define EGL_GL_VIDEO_WIDTH_TI         0x3332  /* eglCreateImageKHR attribute */
+#  define EGL_GL_VIDEO_HEIGHT_TI        0x3333  /* eglCreateImageKHR attribute */
+#  define EGL_GL_VIDEO_BYTE_STRIDE_TI     0x3334  /* eglCreateImageKHR attribute */
+#  define EGL_GL_VIDEO_BYTE_SIZE_TI       0x3335  /* eglCreateImageKHR attribute */
+#  define EGL_GL_VIDEO_YUV_FLAGS_TI       0x3336  /* eglCreateImageKHR attribute */
+#endif
+
+
 CDVDVideoCodecGStreamer::CDVDVideoCodecGStreamer()
 {
   if (gstinitialized == false)
@@ -46,9 +68,16 @@ CDVDVideoCodecGStreamer::CDVDVideoCodecGStreamer()
   m_needData = false;
   m_AppSrc = NULL;
   m_AppSrcCaps = NULL;
+  m_AppSinkCaps = NULL;
   m_ptsinvalid = true;
 
   m_timebase = 1000.0;
+
+  eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)
+      eglGetProcAddress("eglCreateImageKHR");
+  eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)
+      eglGetProcAddress("eglDestroyImageKHR");
+
 }
 
 CDVDVideoCodecGStreamer::~CDVDVideoCodecGStreamer()
@@ -105,6 +134,12 @@ void CDVDVideoCodecGStreamer::Dispose()
     m_AppSrcCaps = NULL;
   }
 
+  if (m_AppSinkCaps)
+  {
+    gst_caps_unref(m_AppSinkCaps);
+    m_AppSinkCaps = NULL;
+  }
+
   if (m_decoder)
   {
     m_decoder->StopThread();
@@ -155,6 +190,7 @@ int CDVDVideoCodecGStreamer::Decode(BYTE* pData, int iSize, double dts, double p
 
 void CDVDVideoCodecGStreamer::Reset()
 {
+  m_crop = false;
 }
 
 bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
@@ -175,37 +211,99 @@ bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     return false;
   }
 
-  GstStructure *structure = gst_caps_get_structure (caps, 0);
-  int width = 0, height = 0;
-  if (structure == NULL ||
-      !gst_structure_get_int (structure, "width", (int *) &width) ||
-      !gst_structure_get_int (structure, "height", (int *) &height))
+  if (caps != m_AppSinkCaps)
   {
-    printf("GStreamer: invalid caps on decoded buffer\n");
-    return false;
-  }
+    if (m_AppSinkCaps)
+      gst_caps_unref(m_AppSinkCaps);
 
-  pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth  = width;
-  pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight = height;
+    m_AppSinkCaps = caps;
 
-  pDvdVideoPicture->format = DVDVideoPicture::FMT_YUV420P;
+    GstStructure *structure = gst_caps_get_structure (caps, 0);
+    if (structure == NULL ||
+        !gst_structure_get_int (structure, "width", &m_width) ||
+        !gst_structure_get_int (structure, "height", &m_height) ||
+        !gst_structure_get_fourcc (structure, "format", &m_format))
+    {
+      printf("GStreamer: invalid caps on decoded buffer\n");
+      gst_caps_unref(m_AppSinkCaps);
+      m_AppSinkCaps = NULL;
+      return false;
+    }
 
-#define ALIGN(x, n) (((x) + (n) - 1) & (~((n) - 1)))
-  pDvdVideoPicture->data[0] = m_pictureBuffer->data;
-  pDvdVideoPicture->iLineSize[0] = ALIGN (width, 4);
-  pDvdVideoPicture->data[1] = pDvdVideoPicture->data[0] + pDvdVideoPicture->iLineSize[0] * ALIGN (height, 2);
-  pDvdVideoPicture->iLineSize[1] = ALIGN (width, 8) / 2;
-  pDvdVideoPicture->data[2] = pDvdVideoPicture->data[1] + pDvdVideoPicture->iLineSize[1] * ALIGN (height, 2) / 2;
-  pDvdVideoPicture->iLineSize[2] = pDvdVideoPicture->iLineSize[1];
-  g_assert (pDvdVideoPicture->data[2] + pDvdVideoPicture->iLineSize[2] * ALIGN (height, 2) / 2 == pDvdVideoPicture->data[0] + m_pictureBuffer->size);
-#undef ALIGN
+    /* we could probably even lift this restriction on color formats
+     * (note: update caps filter in gst pipeline if you do).. this
+     * might make sense on OMAP3 where DSP codecs might be returning
+     * YUY2/UYVY.. at least if we are using eglimageexternal/
+     * texture streaming, the SGX can directly render YUY2/UYVY
+     *
+     * XXX if using eglImage, we need some way to query supported YUV
+     * formats..
+     */
+    if ((m_format != GST_STR_FOURCC("NV12")) &&
+        (m_format != GST_STR_FOURCC("I420")))
+    {
+      printf("GStreamer: invalid color format on decoded buffer\n");
+      gst_caps_unref(m_AppSinkCaps);
+      m_AppSinkCaps = NULL;
+      return false;
+    }
+  }
+  else
+  {
+    gst_caps_unref(caps);
+  }
+
+  pDvdVideoPicture->iWidth  = m_width;
+  pDvdVideoPicture->iHeight = m_height;
 
-  pDvdVideoPicture->pts = (double)GST_BUFFER_TIMESTAMP(m_pictureBuffer) / 1000.0;
+  if (m_crop)
+  {
+    pDvdVideoPicture->iDisplayWidth  = m_cropWidth;
+    pDvdVideoPicture->iDisplayHeight = m_cropHeight;
+    pDvdVideoPicture->iDisplayX      = m_cropLeft;
+    pDvdVideoPicture->iDisplayY      = m_cropTop;
+  }
+  else
+  {
+    pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth;
+    pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
+    pDvdVideoPicture->iDisplayX      = 0;
+    pDvdVideoPicture->iDisplayY      = 0;
+  }
+
+  pDvdVideoPicture->decoder = this;
+  pDvdVideoPicture->origBuf = m_pictureBuffer;
+  pDvdVideoPicture->format  = DVDVideoPicture::FMT_EGLIMG;
+  pDvdVideoPicture->pts       = (double)GST_BUFFER_TIMESTAMP(m_pictureBuffer) / 1000.0;
   pDvdVideoPicture->iDuration = (double)GST_BUFFER_DURATION(m_pictureBuffer) / 1000.0;
 
   return true;
 }
 
+EGLImageKHR CDVDVideoCodecGStreamer::GetEGLImage(void *origBuf)
+{
+  GstBuffer *buf = gst_buffer_ref((GstBuffer *)origBuf);
+  EGLint attr[] = {
+      EGL_GL_VIDEO_FOURCC_TI,      m_format,
+      EGL_GL_VIDEO_WIDTH_TI,       m_width,
+      EGL_GL_VIDEO_HEIGHT_TI,      m_height,
+      EGL_GL_VIDEO_BYTE_SIZE_TI,   GST_BUFFER_SIZE(buf),
+      // TODO: pick proper YUV flags..
+      EGL_GL_VIDEO_YUV_FLAGS_TI,   EGLIMAGE_FLAGS_YUV_CONFORMANT_RANGE |
+                                   EGLIMAGE_FLAGS_YUV_BT601,
+      EGL_NONE
+  };
+  return eglCreateImageKHR(g_Windowing.GetEGLDisplay(),
+      EGL_NO_CONTEXT, EGL_RAW_VIDEO_TI, GST_BUFFER_DATA(buf), attr);
+}
+
+void CDVDVideoCodecGStreamer::ReleaseEGLImage(EGLImageKHR eglImage, void *origBuf)
+{
+  GstBuffer *buf = (GstBuffer *)origBuf;
+  eglDestroyImageKHR(g_Windowing.GetEGLDisplay(), eglImage);
+  gst_buffer_unref(buf);
+}
+
 void CDVDVideoCodecGStreamer::SetDropState(bool bDrop)
 {
 }
@@ -215,8 +313,21 @@ const char *CDVDVideoCodecGStreamer::GetName()
   return "GStreamer";
 }
 
+void CDVDVideoCodecGStreamer::OnCrop(gint top, gint left, gint width, gint height)
+{
+  m_crop = true;
+  m_cropTop = top;
+  m_cropLeft = left;
+  m_cropWidth = width;
+  m_cropHeight = height;
+}
+
 void CDVDVideoCodecGStreamer::OnDecodedBuffer(GstBuffer *buffer)
 {
+  /* throttle decoding if rendering is not keeping up.. */
+  while (m_pictureQueue.size() > 4)
+    usleep(1000);
+
   if (buffer)
   {
     CSingleLock lock(m_monitorLock);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
index d7eb61e..7f22a2d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
@@ -39,9 +39,12 @@ public:
   virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
   virtual void Reset();
   virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual EGLImageKHR GetEGLImage(void *origBuf);
+  virtual void ReleaseEGLImage(EGLImageKHR eglImage, void *origBuf);
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName();
 
+  void OnCrop(gint top, gint left, gint width, gint height);
   void OnDecodedBuffer(GstBuffer *buffer);
   void OnNeedData();
   void OnEnoughData();
@@ -53,6 +56,17 @@ private:
 
   bool m_initialized;
 
+  // crop parameters
+  bool m_crop;
+  gint m_cropTop, m_cropLeft, m_cropWidth, m_cropHeight;
+
+  // caps parameters:
+  gint m_width, m_height;
+  guint32 m_format;
+
+  // sink caps:
+  GstCaps *m_AppSinkCaps;
+
   std::queue<GstBuffer *> m_pictureQueue;
   GstBuffer *m_pictureBuffer;
 
@@ -66,4 +80,8 @@ private:
 
   bool m_needData;
   bool m_ptsinvalid;
+
+
+  PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
index 80e4e11..dba16aa 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
@@ -48,7 +48,7 @@ GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
 
   printf("GStreamer: The capabilities from source are %s\n", capsString);
 
-  gchar *pipelineString = g_strdup_printf("appsrc caps=\"%s\" name=\"AppSrc\" ! decodebin2 ! ffmpegcolorspace ! appsink caps=\"video/x-raw-yuv,format=(fourcc)I420\" name=\"AppSink\"", capsString);
+  gchar *pipelineString = g_strdup_printf("appsrc caps=\"%s\" name=\"AppSrc\" ! decodebin2 ! ffmpegcolorspace ! appsink caps=\"video/x-raw-yuv,format=(fourcc){I420,NV12}\" name=\"AppSink\"", capsString);
 
   printf("GStreamer: Entire pipeline is %s\n", pipelineString);
 
@@ -77,6 +77,7 @@ GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
   if (AppSink)
   {
     g_object_set(G_OBJECT(AppSink), "emit-signals", TRUE, "sync", FALSE, NULL);
+    g_signal_connect(AppSink, "crop", G_CALLBACK(CGstDecoder::OnCrop), this);
     g_signal_connect(AppSink, "new-buffer", G_CALLBACK(CGstDecoder::OnDecodedBuffer), this);
     gst_object_unref(AppSink);
   }
@@ -103,6 +104,13 @@ void CGstDecoder::Process()
   gst_element_set_state(m_pipeline, GST_STATE_NULL);
 }
 
+void CGstDecoder::OnCrop(GstElement *appsink, gint top, gint left, gint width, gint height, void *data)
+{
+  CGstDecoder *decoder = (CGstDecoder *)data;
+  if (decoder->m_callback)
+    decoder->m_callback->OnCrop(top, left, width, height);
+}
+
 void CGstDecoder::OnDecodedBuffer(GstElement *appsink, void *data)
 {
   CGstDecoder *decoder = (CGstDecoder *)data;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
index 75ec2a5..b4c0d07 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
@@ -27,6 +27,7 @@
 class IGstDecoderCallback
 {
 public:
+  virtual void OnCrop(gint top, gint left, gint width, gint height) = 0;
   virtual void OnDecodedBuffer(GstBuffer *buffer) = 0;
   virtual void OnNeedData() = 0;
   virtual void OnEnoughData() = 0;
@@ -45,6 +46,7 @@ protected:
   virtual void Process();
 
 private:
+  static void OnCrop(GstElement *appsink, gint top, gint left, gint width, gint height, void *data);
   static void OnDecodedBuffer(GstElement *appsink, void *data);
   static void OnNeedData(GstElement *appsrc, guint size, void *data);
   static void OnEnoughData (GstElement *appsrc, void *data);
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 95d47b6..da4f62a 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1049,6 +1049,10 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
         flags |= CONF_FLAGS_FORMAT_CVBREF;
         formatstr = "BGRA";
         break;
+      case DVDVideoPicture::FMT_EGLIMG:
+        flags |= CONF_FLAGS_FORMAT_EGLIMG;
+        formatstr = "EGLIMG";
+        break;
     }
 
     if(m_bAllowFullscreen)
diff --git a/xbmc/system.h b/xbmc/system.h
index c838dc8..96cb023 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -269,6 +269,8 @@
   #else
     #include <GLES2/gl2.h>
     #include <GLES2/gl2ext.h>
+    #include <EGL/egl.h>
+    #include <EGL/eglext.h>
   #endif
 #endif
 
-- 
1.7.5.4

