From 7d5b18e603a4f424bf9488c67c9417ea192d44ef Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Sun, 4 Dec 2011 00:47:16 -0600
Subject: [PATCH 08/10] Refcounting and seek fixes

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   35 +++++-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |    1 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |   14 ++-
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.cpp     |   87 +++++++++++---
 .../DVDCodecs/Video/DVDVideoCodecGStreamer.h       |    3 +
 .../cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp |  126 ++++++++------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h  |   29 +++++-
 7 files changed, 195 insertions(+), 100 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index c41ac6a..850db38 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -56,8 +56,30 @@
 #endif
 #include <EGL/eglext.h>
 
+static inline int debug_enabled(void)
+{
+  static int enabled = -1;
+  if (enabled == -1)
+  {
+    char *str = getenv("XBMC_DEBUG");
+    enabled = str && strstr(str, "render");
+  }
+  return enabled;
+}
+
 #ifdef HAVE_LIBGSTREAMER
 #include <gst/gst.h>
+#define DBG(fmt, ...) do { \
+    if (debug_enabled()) \
+    printf("%"GST_TIME_FORMAT"\t%s:%d\t"fmt"\n", \
+        GST_TIME_ARGS(gst_util_get_timestamp()), \
+        __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \
+  } while (0)
+#else
+#define DBG(fmt, ...) do { \
+    if (debug_enabled()) \
+    printf("%s:%d\t"fmt"\n", __PRETTY_FUNCTION, __LINE__, ##__VA_ARGS__); \
+  } while (0)
 #endif
 
 /* for debug */
@@ -140,7 +162,7 @@ void CLinuxRendererGLES::UnRefBuf(int index)
   YUVBUFFER &buf = m_buffers[index];
   if (buf.eglImageHandle)
   {
-    delete buf.eglImageHandle;
+    buf.eglImageHandle->UnRef();
     buf.eglImageHandle = NULL;
   }
 }
@@ -846,6 +868,8 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
   YUVFIELDS &fields = buf.fields;
   YUVPLANES &planes = fields[field];
 
+  DBG("render %d: %f", index, buf.pts);
+
   if (m_reloadShaders)
   {
     m_reloadShaders = 0;
@@ -1403,6 +1427,8 @@ void CLinuxRendererGLES::UploadEGLIMAGETexture(int index)
   YUVFIELDS &fields = buf.fields;
   YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
 
+  DBG("upload %d: %f", index, buf.pts);
+
 #if defined(HAVE_LIBOPENMAX)
   if (!(im.flags&IMAGE_FLAG_READY) || buf.openMaxBuffer)
 #else
@@ -2072,6 +2098,7 @@ void CLinuxRendererGLES::AddProcessor(DVDVideoPicture *picture)
   YUVFIELDS &fields = buf.fields;
   YUVPLANE  &plane  = fields[0][0];   /* for eglimageexternal, use only one texture */
 
+  DBG("add: %p", picture->eglImageHandle);
   UnRefBuf(index);
 
   im.cropX      = picture->iDisplayX;
@@ -2082,8 +2109,8 @@ void CLinuxRendererGLES::AddProcessor(DVDVideoPicture *picture)
   im.height     = m_sourceHeight;
   im.cshift_x   = 1;
   im.cshift_y   = 1;
-  buf.eglImageHandle = picture->eglImageHandle;
-  picture->eglImageHandle = NULL;
+  buf.pts       = picture->pts;
+  buf.eglImageHandle = picture->eglImageHandle->Ref();
 
   plane.texwidth  = im.width;
   plane.texheight = im.height;
@@ -2094,6 +2121,8 @@ void CLinuxRendererGLES::AddProcessor(DVDVideoPicture *picture)
     plane.texheight = NP2(plane.texheight);
   }
 
+  DBG("add %d: %f", index, buf.pts);
+
   // some sanity checking for now.. I plan to move the eglImage related
   // stuff into the union, but need to be sure that no one is still using
   // the data/iLineSize fields..
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 0d17df8..20a1c0f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -255,6 +255,7 @@ protected:
     YV12Image image;
     unsigned  flipindex; /* used to decide if this has been uploaded */
 
+    double pts; // for debugging A/V sync in rendering
     EGLImageHandle *eglImageHandle;
 
 #ifdef HAVE_LIBOPENMAX
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 96112b9..8f5100e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -22,6 +22,7 @@
  */
 
 #include "system.h"
+#include "threads/SingleLock.h"
 
 #include <vector>
 
@@ -47,8 +48,15 @@ struct OpenMaxVideoBuffer;
 class EGLImageHandle
 {
 public:
-  virtual ~EGLImageHandle() {}
+  EGLImageHandle()
+  {
+  }
+  virtual ~EGLImageHandle()
+  {
+  }
   virtual EGLImageKHR Get() = 0;
+  virtual EGLImageHandle * Ref() = 0;
+  virtual void UnRef() = 0;
 };
 
 // should be entirely filled by all codecs
@@ -200,8 +208,8 @@ public:
    */ 
   virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   {
-//    if (pDvdVideoPicture->eglImageHandle)
-//      delete pDvdVideoPicture->eglImageHandle;
+    if (pDvdVideoPicture->eglImageHandle)
+      pDvdVideoPicture->eglImageHandle->UnRef();
     memset(pDvdVideoPicture, 0, sizeof(DVDVideoPicture));
     return true;
   }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
index d1a723f..afac181 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.cpp
@@ -59,29 +59,42 @@ class GSTEGLImageHandle : public EGLImageHandle
 {
 public:
   GSTEGLImageHandle(GstBuffer *buf, gint width, gint height, guint32 format)
+    : EGLImageHandle()
   {
     this->eglImage = NULL;
-    this->buf = buf;
+    this->buf = gst_buffer_ref(buf);
     this->width = width;
     this->height = height;
     this->format = format;
+    this->refcnt = 1;
   }
 
   virtual ~GSTEGLImageHandle()
   {
     if (eglImage)
-    {
       eglDestroyImageKHR(g_Windowing.GetEGLDisplay(), eglImage);
-      gst_buffer_unref(buf);
-    }
+    gst_buffer_unref(buf);
+  }
+
+  virtual EGLImageHandle * Ref()
+  {
+    CSingleLock lock(m_monitorLock);
+    refcnt++;
+    return this;
+  }
+
+  void UnRef()
+  {
+    CSingleLock lock(m_monitorLock);
+    --refcnt;
+    if (refcnt == 0)
+      delete this;
   }
 
-protected:
   virtual EGLImageKHR Get()
   {
     if (!eglImage)
     {
-      GstBuffer *buf = gst_buffer_ref(this->buf);
       EGLint attr[] = {
           EGL_GL_VIDEO_FOURCC_TI,      format,
           EGL_GL_VIDEO_WIDTH_TI,       width,
@@ -99,11 +112,14 @@ protected:
   }
 
 private:
+  static CCriticalSection m_monitorLock;
+  int refcnt;
   EGLImageKHR eglImage;
   gint width, height;
   guint32 format;
   GstBuffer *buf;
 };
+CCriticalSection GSTEGLImageHandle::m_monitorLock;
 
 
 CDVDVideoCodecGStreamer::CDVDVideoCodecGStreamer()
@@ -128,6 +144,8 @@ CDVDVideoCodecGStreamer::CDVDVideoCodecGStreamer()
   m_AppSrcCaps = NULL;
   m_AppSinkCaps = NULL;
   m_ptsinvalid = true;
+  m_drop = false;
+  m_reset = false;
 
   m_timebase = 1000.0;
 }
@@ -154,7 +172,7 @@ bool CDVDVideoCodecGStreamer::Open(CDVDStreamInfo &hints, CDVDCodecOptions &opti
   return (m_AppSrc != NULL);
 }
 
-void CDVDVideoCodecGStreamer::Dispose()
+void CDVDVideoCodecGStreamer::Flush()
 {
   while (m_pictureQueue.size())
   {
@@ -167,6 +185,11 @@ void CDVDVideoCodecGStreamer::Dispose()
     gst_buffer_unref(m_pictureBuffer);
     m_pictureBuffer = NULL;
   }
+}
+
+void CDVDVideoCodecGStreamer::Dispose()
+{
+  Flush();
 
   if (m_AppSrc)
   {
@@ -174,7 +197,7 @@ void CDVDVideoCodecGStreamer::Dispose()
     g_signal_emit_by_name(m_AppSrc, "end-of-stream", &ret);
 
     if (ret != GST_FLOW_OK)
-      printf("GStreamer: OnDispose. Flow error %i\n", ret);
+      ERR("Flow error %i", ret);
 
     gst_object_unref(m_AppSrc);
     m_AppSrc = NULL;
@@ -205,12 +228,21 @@ void CDVDVideoCodecGStreamer::Dispose()
 int CDVDVideoCodecGStreamer::Decode(BYTE* pData, int iSize, double dts, double pts)
 {
   CSingleLock lock(m_monitorLock);
-  usleep(100);
 
   GstBuffer *buffer = NULL;
 
+  if (pts == DVD_NOPTS_VALUE)
+    pts = dts;
+
   if (pData)
   {
+    if (m_reset)
+    {
+      m_decoder->Reset(dts, pts);
+      Flush();
+      m_reset = false;
+    }
+
     buffer = gst_buffer_new_and_alloc(iSize);
     if (buffer)
     {
@@ -218,18 +250,21 @@ int CDVDVideoCodecGStreamer::Decode(BYTE* pData, int iSize, double dts, double p
 
       GST_BUFFER_TIMESTAMP(buffer) = pts * 1000.0;
 
+      DBG("push buffer: %"GST_TIME_FORMAT", dts=%f, pts=%f",
+          GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(buffer)), dts, pts);
+
       GstFlowReturn ret;
       g_signal_emit_by_name(m_AppSrc, "push-buffer", buffer, &ret);
 
       if (ret != GST_FLOW_OK)
-        printf("GStreamer: OnDecode. Flow error %i\n", ret);
+        ERR("Flow error %i", ret);
 
       gst_buffer_unref(buffer);
     }
   }
 
   if (m_pictureBuffer)
- {
+  {
     gst_buffer_unref(m_pictureBuffer);
     m_pictureBuffer = NULL;
   }
@@ -242,7 +277,7 @@ int CDVDVideoCodecGStreamer::Decode(BYTE* pData, int iSize, double dts, double p
 
 void CDVDVideoCodecGStreamer::Reset()
 {
-  m_crop = false;
+  m_reset = true;
 }
 
 bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
@@ -259,7 +294,7 @@ bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   GstCaps *caps = gst_buffer_get_caps(m_pictureBuffer);
   if (caps == NULL)
   {
-    printf("GStreamer: No caps on decoded buffer\n");
+    ERR("No caps on decoded buffer");
     return false;
   }
 
@@ -276,7 +311,7 @@ bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
         !gst_structure_get_int (structure, "height", &m_height) ||
         !gst_structure_get_fourcc (structure, "format", &m_format))
     {
-      printf("GStreamer: invalid caps on decoded buffer\n");
+      ERR("invalid caps on decoded buffer");
       gst_caps_unref(m_AppSinkCaps);
       m_AppSinkCaps = NULL;
       return false;
@@ -294,7 +329,7 @@ bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     if ((m_format != GST_STR_FOURCC("NV12")) &&
         (m_format != GST_STR_FOURCC("I420")))
     {
-      printf("GStreamer: invalid color format on decoded buffer\n");
+      ERR("invalid color format on decoded buffer");
       gst_caps_unref(m_AppSinkCaps);
       m_AppSinkCaps = NULL;
       return false;
@@ -325,14 +360,18 @@ bool CDVDVideoCodecGStreamer::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 
   pDvdVideoPicture->eglImageHandle = new GSTEGLImageHandle(m_pictureBuffer, m_width, m_height, m_format);
   pDvdVideoPicture->format  = DVDVideoPicture::FMT_EGLIMG;
-  pDvdVideoPicture->pts       = (double)GST_BUFFER_TIMESTAMP(m_pictureBuffer) / 1000.0;
+  pDvdVideoPicture->pts     = (double)GST_BUFFER_TIMESTAMP(m_pictureBuffer) / 1000.0;
+  pDvdVideoPicture->dts     = DVD_NOPTS_VALUE;
   pDvdVideoPicture->iDuration = (double)GST_BUFFER_DURATION(m_pictureBuffer) / 1000.0;
 
+  DBG("create %p (%f)", pDvdVideoPicture->eglImageHandle, pDvdVideoPicture->pts);
+
   return true;
 }
 
 void CDVDVideoCodecGStreamer::SetDropState(bool bDrop)
 {
+  m_drop = bDrop;
 }
 
 const char *CDVDVideoCodecGStreamer::GetName()
@@ -351,9 +390,19 @@ void CDVDVideoCodecGStreamer::OnCrop(gint top, gint left, gint width, gint heigh
 
 void CDVDVideoCodecGStreamer::OnDecodedBuffer(GstBuffer *buffer)
 {
+  if (m_drop || m_reset)
+  {
+    DBG("dropping! drop=%d, reset=%d", m_drop, m_reset);
+    gst_buffer_unref (buffer);
+    return;
+  }
+
   /* throttle decoding if rendering is not keeping up.. */
   while (m_pictureQueue.size() > 4)
+  {
+//    DBG("throttling: %d", m_pictureQueue.size());
     usleep(1000);
+  }
 
   if (buffer)
   {
@@ -361,7 +410,7 @@ void CDVDVideoCodecGStreamer::OnDecodedBuffer(GstBuffer *buffer)
     m_pictureQueue.push(buffer);
   }
   else
-    printf("GStreamer: Received null buffer?\n");
+    ERR("Received null buffer?");
 }
 
 void CDVDVideoCodecGStreamer::OnNeedData()
@@ -394,7 +443,7 @@ GstCaps *CDVDVideoCodecGStreamer::CreateVideoCaps(CDVDStreamInfo &hints, CDVDCod
       }
       break;
     default:
-      printf("GStreamer: codec: unkown = %i\n", hints.codec);
+      ERR("codec: unknown = %i", hints.codec);
       break;
   }
 
@@ -419,5 +468,7 @@ GstCaps *CDVDVideoCodecGStreamer::CreateVideoCaps(CDVDStreamInfo &hints, CDVDCod
     }
   }
 
+  DBG("got caps: %"GST_PTR_FORMAT, caps);
+
   return caps;
 }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
index 00e4925..f347c41 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecGStreamer.h
@@ -48,6 +48,7 @@ public:
   void OnEnoughData();
 
 private:
+  virtual void Flush();
   static GstCaps *CreateVideoCaps(CDVDStreamInfo &hints, CDVDCodecOptions &options);
 
   static bool gstinitialized;
@@ -58,6 +59,8 @@ private:
   bool m_crop;
   gint m_cropTop, m_cropLeft, m_cropWidth, m_cropHeight;
 
+  gboolean m_drop, m_reset;
+
   // caps parameters:
   gint m_width, m_height;
   guint32 m_format;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
index dba16aa..d5f898c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.cpp
@@ -46,11 +46,15 @@ GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
 
   gchar *capsString = gst_caps_to_string(sourceCapabilities);
 
-  printf("GStreamer: The capabilities from source are %s\n", capsString);
+  DBG("The capabilities from source are %s", capsString);
 
-  gchar *pipelineString = g_strdup_printf("appsrc caps=\"%s\" name=\"AppSrc\" ! decodebin2 ! ffmpegcolorspace ! appsink caps=\"video/x-raw-yuv,format=(fourcc){I420,NV12}\" name=\"AppSink\"", capsString);
+  gchar *pipelineString = g_strdup_printf(
+      "appsrc caps=\"%s\" name=\"AppSrc\" stream-type=seekable format=time block=(boolean)true ! "
+      "decodebin2 ! ffmpegcolorspace ! "
+      "appsink caps=\"video/x-raw-yuv,format=(fourcc){I420,NV12}\" name=\"AppSink\" max-buffers=3",
+      capsString);
 
-  printf("GStreamer: Entire pipeline is %s\n", pipelineString);
+  DBG("Entire pipeline is %s", pipelineString);
 
   m_pipeline = gst_parse_launch(pipelineString, NULL);
   g_free(capsString);
@@ -64,16 +68,20 @@ GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
   gst_object_unref (bus);
 
   GstElement *AppSrc = gst_bin_get_by_name(GST_BIN(m_pipeline), "AppSrc");
+  m_AppSrc = AppSrc;
 
   if (AppSrc)
   {
     g_signal_connect(AppSrc, "need-data", G_CALLBACK (OnNeedData), this);
     g_signal_connect(AppSrc, "enough-data", G_CALLBACK (OnEnoughData), this);
+    g_signal_connect(AppSrc, "seek-data", G_CALLBACK (OnSeekData), this);
   }
   else
-    printf("GStreamer: Failure to hook up to AppSrc\n");
+    ERR("Failure to hook up to AppSrc");
 
   GstElement *AppSink = gst_bin_get_by_name(GST_BIN(m_pipeline), "AppSink");
+  m_AppSink = AppSink;
+
   if (AppSink)
   {
     g_object_set(G_OBJECT(AppSink), "emit-signals", TRUE, "sync", FALSE, NULL);
@@ -82,7 +90,7 @@ GstElement *CGstDecoder::Open(GstCaps *sourceCapabilities)
     gst_object_unref(AppSink);
   }
   else
-    printf("GStreamer: Failure to hook up to AppSink\n");
+    ERR("Failure to hook up to AppSink");
 
   Create();
 
@@ -95,6 +103,14 @@ void CGstDecoder::StopThread(bool bWait)
   CThread::StopThread(bWait);
 }
 
+void CGstDecoder::Reset(double dts, double pts)
+{
+  GstClockTime time = pts * 1000.0;
+  DBG("Seeking to: %"GST_TIME_FORMAT, GST_TIME_ARGS(time));
+  gst_element_seek(m_AppSrc, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
+      GST_SEEK_TYPE_SET, time, GST_SEEK_TYPE_NONE, 0);
+}
+
 void CGstDecoder::Process()
 {
   gst_element_set_state(m_pipeline, GST_STATE_PLAYING);
@@ -118,13 +134,15 @@ void CGstDecoder::OnDecodedBuffer(GstElement *appsink, void *data)
   GstBuffer *buffer = gst_app_sink_pull_buffer(GST_APP_SINK(appsink));
   if (buffer)
   {
+    DBG("got buffer: %"GST_TIME_FORMAT, GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(buffer)));
+
     if (decoder->m_callback)
       decoder->m_callback->OnDecodedBuffer(buffer);
     else
       gst_buffer_unref(buffer);
   }
   else
-    printf("GStreamer: OnDecodedBuffer - Null Buffer\n");
+    DBG("Null Buffer");
 }
 
 void CGstDecoder::OnNeedData(GstElement *appsrc, guint size, void *data)
@@ -145,6 +163,11 @@ void CGstDecoder::OnEnoughData (GstElement *appsrc, void *data)
     decoder->m_callback->OnEnoughData();
 }
 
+gboolean CGstDecoder::OnSeekData(GstElement *appsrc, guint64 arg, void *data)
+{
+  return TRUE;
+}
+
 gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
 {
   CGstDecoder *decoder = (CGstDecoder *)data;
@@ -153,7 +176,7 @@ gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
   switch (GST_MESSAGE_TYPE(msg))
   {
     case GST_MESSAGE_EOS:
-      g_print ("GStreamer: End of stream\n");
+      DBG("End of stream");
       g_main_loop_quit(decoder->m_loop);
       break;
 
@@ -163,7 +186,7 @@ gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
       gst_message_parse_error (msg, &error, &str);
       g_free (str);
 
-      g_printerr ("GStreamer: Error - %s %s\n", str, error->message);
+      ERR("Error - %s %s", str, error->message);
       g_error_free (error);
 
       g_main_loop_quit(decoder->m_loop);
@@ -175,7 +198,7 @@ gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
       gst_message_parse_error (msg, &warning, &str);
       g_free (str);
 
-      g_printerr ("GStreamer: Warning - %s %s\n", str, warning->message);
+      ERR("Warning - %s %s", str, warning->message);
       g_error_free (warning);
       break;
 
@@ -185,83 +208,36 @@ gboolean CGstDecoder::BusCallback(GstBus *bus, GstMessage *msg, gpointer data)
       gst_message_parse_error (msg, &info, &str);
       g_free (str);
 
-      g_printerr ("GStreamer: Info - %s %s\n", str, info->message);
+      DBG("Info - %s %s", str, info->message);
       g_error_free (info);
       break;
 
-    case GST_MESSAGE_TAG:
-      printf("GStreamer: Message TAG\n");
-      break;
-    case GST_MESSAGE_BUFFERING:
-      printf("GStreamer: Message BUFFERING\n");
-      break;
     case GST_MESSAGE_STATE_CHANGED:
-      printf("GStreamer: Message STATE_CHANGED\n");
+    {
+      /* dump graph for pipeline state changes */
       GstState old_state, new_state;
-      
+      gchar *state_transition_name;
+
       gst_message_parse_state_changed (msg, &old_state, &new_state, NULL);
-      printf("GStreamer: Element %s changed state from %s to %s.\n",
-          GST_OBJECT_NAME (msg->src),
+
+      state_transition_name = g_strdup_printf ("%s_%s",
           gst_element_state_get_name (old_state),
           gst_element_state_get_name (new_state));
+
+      gchar *dump_name = g_strconcat ("xbmc.", state_transition_name, NULL);
+      DBG("dumping: %s", dump_name);
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (decoder->m_pipeline),
+          GST_DEBUG_GRAPH_SHOW_ALL, dump_name);
+      DBG("done");
+
+      g_free (dump_name);
+      g_free (state_transition_name);
+
       break;
-    case GST_MESSAGE_STATE_DIRTY:
-      printf("GStreamer: Message STATE_DIRTY\n");
-      break;
-    case GST_MESSAGE_STEP_DONE:
-      printf("GStreamer: Message STEP_DONE\n");
-      break;
-    case GST_MESSAGE_CLOCK_PROVIDE:
-      printf("GStreamer: Message CLOCK_PROVIDE\n");
-      break;
-    case GST_MESSAGE_CLOCK_LOST:
-      printf("GStreamer: Message CLOCK_LOST\n");
-      break;
-    case GST_MESSAGE_NEW_CLOCK:
-      printf("GStreamer: Message NEW_CLOCK\n");
-      break;
-    case GST_MESSAGE_STRUCTURE_CHANGE:
-      printf("GStreamer: Message STRUCTURE_CHANGE\n");
-      break;
-    case GST_MESSAGE_STREAM_STATUS:
-      printf("GStreamer: Message STREAM_STATUS\n");
-      break;
-    case GST_MESSAGE_APPLICATION:
-      printf("GStreamer: Message APPLICATION\n");
-      break;
-    case GST_MESSAGE_ELEMENT:
-      printf("GStreamer: Message ELEMENT\n");
-      break;
-    case GST_MESSAGE_SEGMENT_START:
-      printf("GStreamer: Message SEGMENT_START\n");
-      break;
-    case GST_MESSAGE_SEGMENT_DONE:
-      printf("GStreamer: Message SEGMENT_DONE\n");
-      break;
-    case GST_MESSAGE_DURATION:
-      printf("GStreamer: Message DURATION\n");
-      break;
-    case GST_MESSAGE_LATENCY:
-      printf("GStreamer: Message LATENCY\n");
-      break;
-    case GST_MESSAGE_ASYNC_START:
-      printf("GStreamer: Message ASYNC_START\n");
-      break;
-    case GST_MESSAGE_ASYNC_DONE:
-      printf("GStreamer: Message ASYNC_DONE\n");
-      break;
-    case GST_MESSAGE_REQUEST_STATE:
-      printf("GStreamer: Message REQUEST_STATE\n");
-      break;
-    case GST_MESSAGE_STEP_START:
-      printf("GStreamer: Message STEP_START\n");
-      break;
-    case GST_MESSAGE_QOS:
-      printf("GStreamer: Message QOS\n");
-      break;
+    }
 
     default:
-      printf("GStreamer: Unknown message %i\n", GST_MESSAGE_TYPE(msg));
+      DBG("%"GST_PTR_FORMAT, msg);
       break;
   }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
index b4c0d07..b9fd950 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/GstDecoder.h
@@ -24,6 +24,30 @@
 #include <queue>
 #include "threads/Thread.h"
 
+static inline int debug_enabled(void)
+{
+  static int enabled = -1;
+  if (enabled == -1)
+  {
+    char *str = getenv("XBMC_DEBUG");
+    enabled = str && strstr(str, "decoder");
+  }
+  return enabled;
+}
+
+#define DBG(fmt, ...) do { \
+    if (debug_enabled()) \
+		printf("%"GST_TIME_FORMAT"\t%s:%d\t"fmt"\n", \
+		    GST_TIME_ARGS(gst_util_get_timestamp()), \
+		    __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \
+  } while (0)
+
+#define ERR(fmt, ...) do { \
+    printf("%"GST_TIME_FORMAT"\t%s:%d\tERROR: "fmt"\n", \
+        GST_TIME_ARGS(gst_util_get_timestamp()), \
+        __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \
+  } while (0)
+
 class IGstDecoderCallback
 {
 public:
@@ -41,6 +65,7 @@ public:
 
   GstElement *Open(GstCaps *sourceCapabilities);
   virtual void StopThread(bool bWait = true);
+  virtual void Reset(double dts, double pts);
 
 protected:
   virtual void Process();
@@ -49,11 +74,13 @@ private:
   static void OnCrop(GstElement *appsink, gint top, gint left, gint width, gint height, void *data);
   static void OnDecodedBuffer(GstElement *appsink, void *data);
   static void OnNeedData(GstElement *appsrc, guint size, void *data);
-  static void OnEnoughData (GstElement *appsrc, void *data);
+  static void OnEnoughData(GstElement *appsrc, void *data);
+  static gboolean OnSeekData(GstElement *appsrc, guint64 arg, void *data);
   static gboolean BusCallback(GstBus *bus, GstMessage *msg, gpointer data);
 
   GstElement *m_pipeline;
   GMainLoop *m_loop;
+  GstElement *m_AppSrc, *m_AppSink;
 
   IGstDecoderCallback *m_callback;
 };
-- 
1.7.5.4

